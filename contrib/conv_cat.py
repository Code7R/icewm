import collections
import csv
import re
#import collections

import sys
#print(csv.list_dialects(), file=sys.stderr)

debug = True

edges = collections.defaultdict(lambda: set())
paths = collections.defaultdict(lambda: list())
hints = dict()

# a few special ones, those from the spec are added from table input
main_cats = {"Accessibility", "Screensavers", "WINE", "Other"}


def add_edges(key :str, multicand :list):
    global edges
    print(f"{key} -> {multicand}", file=sys.stderr)
    edges[key] |= set(multicand)


with open('Main_Categories.csv', newline='') as csvfile:
    rdr = csv.reader(csvfile, dialect='unix')
    for row in rdr:
        #print(row)
        assert(len(row) == 3)
        if " " in row[0]:  # the header
            continue
        main_cats.add(row[0].strip())
        hints[row[0]] = row[1]


with open('Additional_Categories.csv', newline='') as csvfile:
    rdr = csv.reader(csvfile, dialect='unix')
    for row in rdr:
        #print(row)
        assert(len(row) == 3)
        if " " in row[0]:  # the header
            continue
        multicand = list(map(lambda s: s.strip(), re.split(r'\sor\s', row[2])))
        add_edges(row[0], multicand)
        hints[row[0]] = row[1]


#print(edges, file=sys.stderr)


def xxx():
    """
    Probably BS, trying to expand the graph, but fails on equally named nodes.
    :return:
    """
    global edges
    keyz = list(edges.keys())
    for k in keyz:
        temp = list(edges[k])
        newset = set()
        for vv in temp:
            xp = vv.split(';')
            if len(xp) == 1:
                continue
            #print(f"multi cand? {k} <-> {vv}")
            newset.add(xp[-1])
            chain = list(xp)
            chain.append(k)
            print(f"chain? {chain}", file=sys.stderr)
            while len(chain) > 1:
                add_edges(chain[-1], [chain[-2]])
                chain.pop(-1)
            edges[k] = newset


for k, v in edges.items():
    for vv in v:
        #print(f"XX: {vv}")
        xp = [k] + list(reversed(vv.strip().split(';')))
        if not xp[-1]:
            xp[-1] = "Other"
        if xp[-1] not in main_cats:
            xp = xp + ["Other"]
        if debug: print(f"{len(xp)} -> {xp}", file=sys.stderr)
        paths[len(xp)].append(xp)

paths[1] = list(map(lambda x: [x], main_cats))

if debug: print(paths, file=sys.stderr)

keysByLen = list(reversed(sorted(paths.keys())))

print(f"""/**
 * WARNING: this file is autogenerated! Any change might be overwritten!
 *
 * Content is created using conv_cat.py with input from
 * https://specifications.freedesktop.org/menu-spec/latest/additional-category-registry.html
 * (i.e. the table transformed with LibreOffice to CSV format).
 */ 

#ifndef FDO_GEN_MENU_STRUCTURE_H
#define FDO_GEN_MENU_STRUCTURE_H

#include <initializer_list>

using t_menu_path = std::initializer_list<const char*>;
using t_menu_path_table = std::initializer_list<t_menu_path>;
using t_menu_path_table_list = std::initializer_list<t_menu_path_table>;

#define MENU_DEPTH_MAX {keysByLen[0]}

constexpr t_menu_path_table_list valid_paths = {{""")

for k in keysByLen:
    print(f"\n\t// menu locations of depth {k}\n\t{{")
    byFirst = sorted(paths[k], key=lambda l: l[0])
    for v in byFirst:
        print("\t\t{")
        for t in v:
            print("// TRANSLATORS: This is a SHORT category menu name from freedesktop.org. Please add compact punctuation if needed but no double-quotes! Hint for the content inside: " + hints.get(t, t))
            print("\t\t\tN_(\"" + t + "\"),")
        print("\t\t},")
    print("\t},")

print(f"""}};

#define SIZE_OF_MENU_TABLE {len(keysByLen)}

#endif // FDO_GEN_MENU_STRUCTURE_H""")
